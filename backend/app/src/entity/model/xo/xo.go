// Package xo contains generated code for schema 'sample'.
package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"time"
)

var (
	// logf is used by generated code to log SQL queries.
	logf = func(string, ...interface{}) {}
	// errf is used by generated code to log SQL errors.
	errf = func(string, ...interface{}) {}
)

// logerror logs the error and returns it.
func logerror(err error) error {
	errf("ERROR: %v", err)
	return err
}

// Logf logs a message using the package logger.
func Logf(s string, v ...interface{}) {
	logf(s, v...)
}

// SetLogger sets the package logger. Valid logger types:
//
//	io.Writer
//	func(string, ...interface{}) (int, error) // fmt.Printf
//	func(string, ...interface{}) // log.Printf
func SetLogger(logger interface{}) {
	logf = convLogger(logger)
}

// Errorf logs an error message using the package error logger.
func Errorf(s string, v ...interface{}) {
	errf(s, v...)
}

// SetErrorLogger sets the package error logger. Valid logger types:
//
//	io.Writer
//	func(string, ...interface{}) (int, error) // fmt.Printf
//	func(string, ...interface{}) // log.Printf
func SetErrorLogger(logger interface{}) {
	errf = convLogger(logger)
}

// convLogger converts logger to the standard logger interface.
func convLogger(logger interface{}) func(string, ...interface{}) {
	switch z := logger.(type) {
	case io.Writer:
		return func(s string, v ...interface{}) {
			fmt.Fprintf(z, s, v...)
		}
	case func(string, ...interface{}) (int, error): // fmt.Printf
		return func(s string, v ...interface{}) {
			_, _ = z(s, v...)
		}
	case func(string, ...interface{}): // log.Printf
		return z
	}
	panic(fmt.Sprintf("unsupported logger type %T", logger))
}

// DB is the common interface for database operations that can be used with
// types from schema 'sample'.
//
// This works with both database/sql.DB and database/sql.Tx.
type DB interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// Error is an error.
type Error string

// Error satisfies the error interface.
func (err Error) Error() string {
	return string(err)
}

// Error values.
const (
	// ErrAlreadyExists is the already exists error.
	ErrAlreadyExists Error = "already exists"
	// ErrDoesNotExist is the does not exist error.
	ErrDoesNotExist Error = "does not exist"
	// ErrMarkedForDeletion is the marked for deletion error.
	ErrMarkedForDeletion Error = "marked for deletion"
)

// ErrInsertFailed is the insert failed error.
type ErrInsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrInsertFailed) Error() string {
	return fmt.Sprintf("insert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrInsertFailed) Unwrap() error {
	return err.Err
}

// ErrUpdateFailed is the update failed error.
type ErrUpdateFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpdateFailed) Error() string {
	return fmt.Sprintf("update failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpdateFailed) Unwrap() error {
	return err.Err
}

// ErrUpsertFailed is the upsert failed error.
type ErrUpsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpsertFailed) Error() string {
	return fmt.Sprintf("upsert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpsertFailed) Unwrap() error {
	return err.Err
}

// Category represents a row from 'sample.categories'.
type Category struct {
	CategoryID   int            `json:"category_id"`   // category_id
	CategoryName string         `json:"category_name"` // category_name
	CategoryIcon sql.NullString `json:"category_icon"` // category_icon
	CreatedAt    time.Time      `json:"created_at"`    // created_at
	UpdatedAt    sql.NullTime   `json:"updated_at"`    // updated_at
	DeletedAt    sql.NullTime   `json:"deleted_at"`    // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Category exists in the database.
func (c *Category) Exists() bool {
	return c._exists
}

// Deleted returns true when the Category has been marked for deletion from
// the database.
func (c *Category) Deleted() bool {
	return c._deleted
}

// Insert inserts the Category to the database.
func (c *Category) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.categories (` +
		`category_name, category_icon, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, c.CategoryName, c.CategoryIcon, c.CreatedAt, c.UpdatedAt, c.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, c.CategoryName, c.CategoryIcon, c.CreatedAt, c.UpdatedAt, c.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	c.CategoryID = int(id)
	// set exists
	c._exists = true
	return nil
}

// Update updates a Category in the database.
func (c *Category) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.categories SET ` +
		`category_name = ?, category_icon = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE category_id = ?`
	// run
	logf(sqlstr, c.CategoryName, c.CategoryIcon, c.CreatedAt, c.UpdatedAt, c.DeletedAt, c.CategoryID)
	if _, err := db.ExecContext(ctx, sqlstr, c.CategoryName, c.CategoryIcon, c.CreatedAt, c.UpdatedAt, c.DeletedAt, c.CategoryID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Category to the database.
func (c *Category) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for Category.
func (c *Category) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.categories (` +
		`category_id, category_name, category_icon, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`category_name = VALUES(category_name), category_icon = VALUES(category_icon), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, c.CategoryID, c.CategoryName, c.CategoryIcon, c.CreatedAt, c.UpdatedAt, c.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, c.CategoryID, c.CategoryName, c.CategoryIcon, c.CreatedAt, c.UpdatedAt, c.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the Category from the database.
func (c *Category) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.categories ` +
		`WHERE category_id = ?`
	// run
	logf(sqlstr, c.CategoryID)
	if _, err := db.ExecContext(ctx, sqlstr, c.CategoryID); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// JUsersCategory represents a row from 'sample.j_users_categories'.
type JUsersCategory struct {
	JUserCategoryID int          `json:"j_user_category_id"` // j_user_category_id
	UserID          int          `json:"user_id"`            // user_id
	CategoryID      int          `json:"category_id"`        // category_id
	CreatedAt       time.Time    `json:"created_at"`         // created_at
	UpdatedAt       sql.NullTime `json:"updated_at"`         // updated_at
	DeletedAt       sql.NullTime `json:"deleted_at"`         // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the JUsersCategory exists in the database.
func (juc *JUsersCategory) Exists() bool {
	return juc._exists
}

// Deleted returns true when the JUsersCategory has been marked for deletion from
// the database.
func (juc *JUsersCategory) Deleted() bool {
	return juc._deleted
}

// Insert inserts the JUsersCategory to the database.
func (juc *JUsersCategory) Insert(ctx context.Context, db DB) error {
	switch {
	case juc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case juc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.j_users_categories (` +
		`user_id, category_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, juc.UserID, juc.CategoryID, juc.CreatedAt, juc.UpdatedAt, juc.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, juc.UserID, juc.CategoryID, juc.CreatedAt, juc.UpdatedAt, juc.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	juc.JUserCategoryID = int(id)
	// set exists
	juc._exists = true
	return nil
}

// Update updates a JUsersCategory in the database.
func (juc *JUsersCategory) Update(ctx context.Context, db DB) error {
	switch {
	case !juc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case juc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.j_users_categories SET ` +
		`user_id = ?, category_id = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE j_user_category_id = ?`
	// run
	logf(sqlstr, juc.UserID, juc.CategoryID, juc.CreatedAt, juc.UpdatedAt, juc.DeletedAt, juc.JUserCategoryID)
	if _, err := db.ExecContext(ctx, sqlstr, juc.UserID, juc.CategoryID, juc.CreatedAt, juc.UpdatedAt, juc.DeletedAt, juc.JUserCategoryID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the JUsersCategory to the database.
func (juc *JUsersCategory) Save(ctx context.Context, db DB) error {
	if juc.Exists() {
		return juc.Update(ctx, db)
	}
	return juc.Insert(ctx, db)
}

// Upsert performs an upsert for JUsersCategory.
func (juc *JUsersCategory) Upsert(ctx context.Context, db DB) error {
	switch {
	case juc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.j_users_categories (` +
		`j_user_category_id, user_id, category_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`user_id = VALUES(user_id), category_id = VALUES(category_id), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, juc.JUserCategoryID, juc.UserID, juc.CategoryID, juc.CreatedAt, juc.UpdatedAt, juc.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, juc.JUserCategoryID, juc.UserID, juc.CategoryID, juc.CreatedAt, juc.UpdatedAt, juc.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	juc._exists = true
	return nil
}

// Delete deletes the JUsersCategory from the database.
func (juc *JUsersCategory) Delete(ctx context.Context, db DB) error {
	switch {
	case !juc._exists: // doesn't exist
		return nil
	case juc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.j_users_categories ` +
		`WHERE j_user_category_id = ?`
	// run
	logf(sqlstr, juc.JUserCategoryID)
	if _, err := db.ExecContext(ctx, sqlstr, juc.JUserCategoryID); err != nil {
		return logerror(err)
	}
	// set deleted
	juc._deleted = true
	return nil
}

// JUsersTeam represents a row from 'sample.j_users_teams'.
type JUsersTeam struct {
	JUserTeamID int          `json:"j_user_team_id"` // j_user_team_id
	UserID      int          `json:"user_id"`        // user_id
	TeamID      int          `json:"team_id"`        // team_id
	CreatedAt   time.Time    `json:"created_at"`     // created_at
	UpdatedAt   sql.NullTime `json:"updated_at"`     // updated_at
	DeletedAt   sql.NullTime `json:"deleted_at"`     // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the JUsersTeam exists in the database.
func (jut *JUsersTeam) Exists() bool {
	return jut._exists
}

// Deleted returns true when the JUsersTeam has been marked for deletion from
// the database.
func (jut *JUsersTeam) Deleted() bool {
	return jut._deleted
}

// Insert inserts the JUsersTeam to the database.
func (jut *JUsersTeam) Insert(ctx context.Context, db DB) error {
	switch {
	case jut._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case jut._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.j_users_teams (` +
		`user_id, team_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, jut.UserID, jut.TeamID, jut.CreatedAt, jut.UpdatedAt, jut.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, jut.UserID, jut.TeamID, jut.CreatedAt, jut.UpdatedAt, jut.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	jut.JUserTeamID = int(id)
	// set exists
	jut._exists = true
	return nil
}

// Update updates a JUsersTeam in the database.
func (jut *JUsersTeam) Update(ctx context.Context, db DB) error {
	switch {
	case !jut._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case jut._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.j_users_teams SET ` +
		`user_id = ?, team_id = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE j_user_team_id = ?`
	// run
	logf(sqlstr, jut.UserID, jut.TeamID, jut.CreatedAt, jut.UpdatedAt, jut.DeletedAt, jut.JUserTeamID)
	if _, err := db.ExecContext(ctx, sqlstr, jut.UserID, jut.TeamID, jut.CreatedAt, jut.UpdatedAt, jut.DeletedAt, jut.JUserTeamID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the JUsersTeam to the database.
func (jut *JUsersTeam) Save(ctx context.Context, db DB) error {
	if jut.Exists() {
		return jut.Update(ctx, db)
	}
	return jut.Insert(ctx, db)
}

// Upsert performs an upsert for JUsersTeam.
func (jut *JUsersTeam) Upsert(ctx context.Context, db DB) error {
	switch {
	case jut._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.j_users_teams (` +
		`j_user_team_id, user_id, team_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`user_id = VALUES(user_id), team_id = VALUES(team_id), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, jut.JUserTeamID, jut.UserID, jut.TeamID, jut.CreatedAt, jut.UpdatedAt, jut.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, jut.JUserTeamID, jut.UserID, jut.TeamID, jut.CreatedAt, jut.UpdatedAt, jut.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	jut._exists = true
	return nil
}

// Delete deletes the JUsersTeam from the database.
func (jut *JUsersTeam) Delete(ctx context.Context, db DB) error {
	switch {
	case !jut._exists: // doesn't exist
		return nil
	case jut._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.j_users_teams ` +
		`WHERE j_user_team_id = ?`
	// run
	logf(sqlstr, jut.JUserTeamID)
	if _, err := db.ExecContext(ctx, sqlstr, jut.JUserTeamID); err != nil {
		return logerror(err)
	}
	// set deleted
	jut._deleted = true
	return nil
}

// Migration represents a row from 'sample.migrations'.
type Migration struct {
	ID        string       `json:"id"`         // id
	AppliedAt sql.NullTime `json:"applied_at"` // applied_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Migration exists in the database.
func (m *Migration) Exists() bool {
	return m._exists
}

// Deleted returns true when the Migration has been marked for deletion from
// the database.
func (m *Migration) Deleted() bool {
	return m._deleted
}

// Insert inserts the Migration to the database.
func (m *Migration) Insert(ctx context.Context, db DB) error {
	switch {
	case m._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case m._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO sample.migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`?, ?` +
		`)`
	// run
	logf(sqlstr, m.ID, m.AppliedAt)
	if _, err := db.ExecContext(ctx, sqlstr, m.ID, m.AppliedAt); err != nil {
		return logerror(err)
	}
	// set exists
	m._exists = true
	return nil
}

// Update updates a Migration in the database.
func (m *Migration) Update(ctx context.Context, db DB) error {
	switch {
	case !m._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case m._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.migrations SET ` +
		`applied_at = ? ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, m.AppliedAt, m.ID)
	if _, err := db.ExecContext(ctx, sqlstr, m.AppliedAt, m.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Migration to the database.
func (m *Migration) Save(ctx context.Context, db DB) error {
	if m.Exists() {
		return m.Update(ctx, db)
	}
	return m.Insert(ctx, db)
}

// Upsert performs an upsert for Migration.
func (m *Migration) Upsert(ctx context.Context, db DB) error {
	switch {
	case m._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`id = VALUES(id), applied_at = VALUES(applied_at)`
	// run
	logf(sqlstr, m.ID, m.AppliedAt)
	if _, err := db.ExecContext(ctx, sqlstr, m.ID, m.AppliedAt); err != nil {
		return logerror(err)
	}
	// set exists
	m._exists = true
	return nil
}

// Delete deletes the Migration from the database.
func (m *Migration) Delete(ctx context.Context, db DB) error {
	switch {
	case !m._exists: // doesn't exist
		return nil
	case m._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.migrations ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, m.ID)
	if _, err := db.ExecContext(ctx, sqlstr, m.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	m._deleted = true
	return nil
}

// Role represents a row from 'sample.roles'.
type Role struct {
	RoleID    int            `json:"role_id"`    // role_id
	RoleIcon  sql.NullString `json:"role_icon"`  // role_icon
	RoleName  string         `json:"role_name"`  // role_name
	CreatedAt time.Time      `json:"created_at"` // created_at
	UpdatedAt sql.NullTime   `json:"updated_at"` // updated_at
	DeletedAt sql.NullTime   `json:"deleted_at"` // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Role exists in the database.
func (r *Role) Exists() bool {
	return r._exists
}

// Deleted returns true when the Role has been marked for deletion from
// the database.
func (r *Role) Deleted() bool {
	return r._deleted
}

// Insert inserts the Role to the database.
func (r *Role) Insert(ctx context.Context, db DB) error {
	switch {
	case r._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case r._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.roles (` +
		`role_icon, role_name, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, r.RoleIcon, r.RoleName, r.CreatedAt, r.UpdatedAt, r.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, r.RoleIcon, r.RoleName, r.CreatedAt, r.UpdatedAt, r.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	r.RoleID = int(id)
	// set exists
	r._exists = true
	return nil
}

// Update updates a Role in the database.
func (r *Role) Update(ctx context.Context, db DB) error {
	switch {
	case !r._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case r._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.roles SET ` +
		`role_icon = ?, role_name = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE role_id = ?`
	// run
	logf(sqlstr, r.RoleIcon, r.RoleName, r.CreatedAt, r.UpdatedAt, r.DeletedAt, r.RoleID)
	if _, err := db.ExecContext(ctx, sqlstr, r.RoleIcon, r.RoleName, r.CreatedAt, r.UpdatedAt, r.DeletedAt, r.RoleID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Role to the database.
func (r *Role) Save(ctx context.Context, db DB) error {
	if r.Exists() {
		return r.Update(ctx, db)
	}
	return r.Insert(ctx, db)
}

// Upsert performs an upsert for Role.
func (r *Role) Upsert(ctx context.Context, db DB) error {
	switch {
	case r._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.roles (` +
		`role_id, role_icon, role_name, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`role_icon = VALUES(role_icon), role_name = VALUES(role_name), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, r.RoleID, r.RoleIcon, r.RoleName, r.CreatedAt, r.UpdatedAt, r.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, r.RoleID, r.RoleIcon, r.RoleName, r.CreatedAt, r.UpdatedAt, r.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	r._exists = true
	return nil
}

// Delete deletes the Role from the database.
func (r *Role) Delete(ctx context.Context, db DB) error {
	switch {
	case !r._exists: // doesn't exist
		return nil
	case r._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.roles ` +
		`WHERE role_id = ?`
	// run
	logf(sqlstr, r.RoleID)
	if _, err := db.ExecContext(ctx, sqlstr, r.RoleID); err != nil {
		return logerror(err)
	}
	// set deleted
	r._deleted = true
	return nil
}

// Task represents a row from 'sample.tasks'.
type Task struct {
	TaskID        int            `json:"task_id"`         // task_id
	TaskName      string         `json:"task_name"`       // task_name
	Link          sql.NullString `json:"link"`            // link
	Level         int            `json:"level"`           // level
	Description   sql.NullString `json:"description"`     // description
	IsReview      bool           `json:"is_review"`       // is_review
	IsAllRequired bool           `json:"is_all_required"` // is_all_required
	CategoryID    int            `json:"category_id"`     // category_id
	CreatedAt     time.Time      `json:"created_at"`      // created_at
	UpdatedAt     sql.NullTime   `json:"updated_at"`      // updated_at
	DeletedAt     sql.NullTime   `json:"deleted_at"`      // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Task exists in the database.
func (t *Task) Exists() bool {
	return t._exists
}

// Deleted returns true when the Task has been marked for deletion from
// the database.
func (t *Task) Deleted() bool {
	return t._deleted
}

// Insert inserts the Task to the database.
func (t *Task) Insert(ctx context.Context, db DB) error {
	switch {
	case t._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case t._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.tasks (` +
		`task_name, link, level, description, is_review, is_all_required, category_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, t.TaskName, t.Link, t.Level, t.Description, t.IsReview, t.IsAllRequired, t.CategoryID, t.CreatedAt, t.UpdatedAt, t.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, t.TaskName, t.Link, t.Level, t.Description, t.IsReview, t.IsAllRequired, t.CategoryID, t.CreatedAt, t.UpdatedAt, t.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	t.TaskID = int(id)
	// set exists
	t._exists = true
	return nil
}

// Update updates a Task in the database.
func (t *Task) Update(ctx context.Context, db DB) error {
	switch {
	case !t._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case t._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.tasks SET ` +
		`task_name = ?, link = ?, level = ?, description = ?, is_review = ?, is_all_required = ?, category_id = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE task_id = ?`
	// run
	logf(sqlstr, t.TaskName, t.Link, t.Level, t.Description, t.IsReview, t.IsAllRequired, t.CategoryID, t.CreatedAt, t.UpdatedAt, t.DeletedAt, t.TaskID)
	if _, err := db.ExecContext(ctx, sqlstr, t.TaskName, t.Link, t.Level, t.Description, t.IsReview, t.IsAllRequired, t.CategoryID, t.CreatedAt, t.UpdatedAt, t.DeletedAt, t.TaskID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Task to the database.
func (t *Task) Save(ctx context.Context, db DB) error {
	if t.Exists() {
		return t.Update(ctx, db)
	}
	return t.Insert(ctx, db)
}

// Upsert performs an upsert for Task.
func (t *Task) Upsert(ctx context.Context, db DB) error {
	switch {
	case t._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.tasks (` +
		`task_id, task_name, link, level, description, is_review, is_all_required, category_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`task_name = VALUES(task_name), link = VALUES(link), level = VALUES(level), description = VALUES(description), is_review = VALUES(is_review), is_all_required = VALUES(is_all_required), category_id = VALUES(category_id), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, t.TaskID, t.TaskName, t.Link, t.Level, t.Description, t.IsReview, t.IsAllRequired, t.CategoryID, t.CreatedAt, t.UpdatedAt, t.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, t.TaskID, t.TaskName, t.Link, t.Level, t.Description, t.IsReview, t.IsAllRequired, t.CategoryID, t.CreatedAt, t.UpdatedAt, t.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	t._exists = true
	return nil
}

// Delete deletes the Task from the database.
func (t *Task) Delete(ctx context.Context, db DB) error {
	switch {
	case !t._exists: // doesn't exist
		return nil
	case t._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.tasks ` +
		`WHERE task_id = ?`
	// run
	logf(sqlstr, t.TaskID)
	if _, err := db.ExecContext(ctx, sqlstr, t.TaskID); err != nil {
		return logerror(err)
	}
	// set deleted
	t._deleted = true
	return nil
}

// TaskFlag represents a row from 'sample.task_flags'.
type TaskFlag struct {
	TaskFlagID   int          `json:"task_flag_id"`   // task_flag_id
	TaskFlagName string       `json:"task_flag_name"` // task_flag_name
	CreatedAt    time.Time    `json:"created_at"`     // created_at
	UpdatedAt    sql.NullTime `json:"updated_at"`     // updated_at
	DeletedAt    sql.NullTime `json:"deleted_at"`     // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the TaskFlag exists in the database.
func (tf *TaskFlag) Exists() bool {
	return tf._exists
}

// Deleted returns true when the TaskFlag has been marked for deletion from
// the database.
func (tf *TaskFlag) Deleted() bool {
	return tf._deleted
}

// Insert inserts the TaskFlag to the database.
func (tf *TaskFlag) Insert(ctx context.Context, db DB) error {
	switch {
	case tf._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case tf._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.task_flags (` +
		`task_flag_name, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, tf.TaskFlagName, tf.CreatedAt, tf.UpdatedAt, tf.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, tf.TaskFlagName, tf.CreatedAt, tf.UpdatedAt, tf.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	tf.TaskFlagID = int(id)
	// set exists
	tf._exists = true
	return nil
}

// Update updates a TaskFlag in the database.
func (tf *TaskFlag) Update(ctx context.Context, db DB) error {
	switch {
	case !tf._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case tf._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.task_flags SET ` +
		`task_flag_name = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE task_flag_id = ?`
	// run
	logf(sqlstr, tf.TaskFlagName, tf.CreatedAt, tf.UpdatedAt, tf.DeletedAt, tf.TaskFlagID)
	if _, err := db.ExecContext(ctx, sqlstr, tf.TaskFlagName, tf.CreatedAt, tf.UpdatedAt, tf.DeletedAt, tf.TaskFlagID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the TaskFlag to the database.
func (tf *TaskFlag) Save(ctx context.Context, db DB) error {
	if tf.Exists() {
		return tf.Update(ctx, db)
	}
	return tf.Insert(ctx, db)
}

// Upsert performs an upsert for TaskFlag.
func (tf *TaskFlag) Upsert(ctx context.Context, db DB) error {
	switch {
	case tf._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.task_flags (` +
		`task_flag_id, task_flag_name, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`task_flag_name = VALUES(task_flag_name), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, tf.TaskFlagID, tf.TaskFlagName, tf.CreatedAt, tf.UpdatedAt, tf.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, tf.TaskFlagID, tf.TaskFlagName, tf.CreatedAt, tf.UpdatedAt, tf.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	tf._exists = true
	return nil
}

// Delete deletes the TaskFlag from the database.
func (tf *TaskFlag) Delete(ctx context.Context, db DB) error {
	switch {
	case !tf._exists: // doesn't exist
		return nil
	case tf._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.task_flags ` +
		`WHERE task_flag_id = ?`
	// run
	logf(sqlstr, tf.TaskFlagID)
	if _, err := db.ExecContext(ctx, sqlstr, tf.TaskFlagID); err != nil {
		return logerror(err)
	}
	// set deleted
	tf._deleted = true
	return nil
}

// TaskStatus represents a row from 'sample.task_status'.
type TaskStatus struct {
	TaskStateID int          `json:"task_state_id"` // task_state_id
	UserID      int          `json:"user_id"`       // user_id
	TaskID      int          `json:"task_id"`       // task_id
	TaskFlagID  int          `json:"task_flag_id"`  // task_flag_id
	Progress    int          `json:"progress"`      // progress
	CreatedAt   time.Time    `json:"created_at"`    // created_at
	UpdatedAt   sql.NullTime `json:"updated_at"`    // updated_at
	DeletedAt   sql.NullTime `json:"deleted_at"`    // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the TaskStatus exists in the database.
func (ts *TaskStatus) Exists() bool {
	return ts._exists
}

// Deleted returns true when the TaskStatus has been marked for deletion from
// the database.
func (ts *TaskStatus) Deleted() bool {
	return ts._deleted
}

// Insert inserts the TaskStatus to the database.
func (ts *TaskStatus) Insert(ctx context.Context, db DB) error {
	switch {
	case ts._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ts._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.task_status (` +
		`user_id, task_id, task_flag_id, progress, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, ts.UserID, ts.TaskID, ts.TaskFlagID, ts.Progress, ts.CreatedAt, ts.UpdatedAt, ts.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, ts.UserID, ts.TaskID, ts.TaskFlagID, ts.Progress, ts.CreatedAt, ts.UpdatedAt, ts.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	ts.TaskStateID = int(id)
	// set exists
	ts._exists = true
	return nil
}

// Update updates a TaskStatus in the database.
func (ts *TaskStatus) Update(ctx context.Context, db DB) error {
	switch {
	case !ts._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ts._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.task_status SET ` +
		`user_id = ?, task_id = ?, task_flag_id = ?, progress = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE task_state_id = ?`
	// run
	logf(sqlstr, ts.UserID, ts.TaskID, ts.TaskFlagID, ts.Progress, ts.CreatedAt, ts.UpdatedAt, ts.DeletedAt, ts.TaskStateID)
	if _, err := db.ExecContext(ctx, sqlstr, ts.UserID, ts.TaskID, ts.TaskFlagID, ts.Progress, ts.CreatedAt, ts.UpdatedAt, ts.DeletedAt, ts.TaskStateID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the TaskStatus to the database.
func (ts *TaskStatus) Save(ctx context.Context, db DB) error {
	if ts.Exists() {
		return ts.Update(ctx, db)
	}
	return ts.Insert(ctx, db)
}

// Upsert performs an upsert for TaskStatus.
func (ts *TaskStatus) Upsert(ctx context.Context, db DB) error {
	switch {
	case ts._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.task_status (` +
		`task_state_id, user_id, task_id, task_flag_id, progress, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`user_id = VALUES(user_id), task_id = VALUES(task_id), task_flag_id = VALUES(task_flag_id), progress = VALUES(progress), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, ts.TaskStateID, ts.UserID, ts.TaskID, ts.TaskFlagID, ts.Progress, ts.CreatedAt, ts.UpdatedAt, ts.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ts.TaskStateID, ts.UserID, ts.TaskID, ts.TaskFlagID, ts.Progress, ts.CreatedAt, ts.UpdatedAt, ts.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ts._exists = true
	return nil
}

// Delete deletes the TaskStatus from the database.
func (ts *TaskStatus) Delete(ctx context.Context, db DB) error {
	switch {
	case !ts._exists: // doesn't exist
		return nil
	case ts._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.task_status ` +
		`WHERE task_state_id = ?`
	// run
	logf(sqlstr, ts.TaskStateID)
	if _, err := db.ExecContext(ctx, sqlstr, ts.TaskStateID); err != nil {
		return logerror(err)
	}
	// set deleted
	ts._deleted = true
	return nil
}

// Team represents a row from 'sample.teams'.
type Team struct {
	TeamID    int            `json:"team_id"`    // team_id
	TeamName  string         `json:"team_name"`  // team_name
	TeamIcon  sql.NullString `json:"team_icon"`  // team_icon
	TeamMemo  sql.NullString `json:"team_memo"`  // team_memo
	StartDate time.Time      `json:"start_date"` // start_date
	EndDate   sql.NullTime   `json:"end_date"`   // end_date
	IsEnd     bool           `json:"is_end"`     // is_end
	CreatedAt time.Time      `json:"created_at"` // created_at
	UpdatedAt sql.NullTime   `json:"updated_at"` // updated_at
	DeletedAt sql.NullTime   `json:"deleted_at"` // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Team exists in the database.
func (t *Team) Exists() bool {
	return t._exists
}

// Deleted returns true when the Team has been marked for deletion from
// the database.
func (t *Team) Deleted() bool {
	return t._deleted
}

// Insert inserts the Team to the database.
func (t *Team) Insert(ctx context.Context, db DB) error {
	switch {
	case t._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case t._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.teams (` +
		`team_name, team_icon, team_memo, start_date, end_date, is_end, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, t.TeamName, t.TeamIcon, t.TeamMemo, t.StartDate, t.EndDate, t.IsEnd, t.CreatedAt, t.UpdatedAt, t.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, t.TeamName, t.TeamIcon, t.TeamMemo, t.StartDate, t.EndDate, t.IsEnd, t.CreatedAt, t.UpdatedAt, t.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	t.TeamID = int(id)
	// set exists
	t._exists = true
	return nil
}

// Update updates a Team in the database.
func (t *Team) Update(ctx context.Context, db DB) error {
	switch {
	case !t._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case t._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.teams SET ` +
		`team_name = ?, team_icon = ?, team_memo = ?, start_date = ?, end_date = ?, is_end = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE team_id = ?`
	// run
	logf(sqlstr, t.TeamName, t.TeamIcon, t.TeamMemo, t.StartDate, t.EndDate, t.IsEnd, t.CreatedAt, t.UpdatedAt, t.DeletedAt, t.TeamID)
	if _, err := db.ExecContext(ctx, sqlstr, t.TeamName, t.TeamIcon, t.TeamMemo, t.StartDate, t.EndDate, t.IsEnd, t.CreatedAt, t.UpdatedAt, t.DeletedAt, t.TeamID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Team to the database.
func (t *Team) Save(ctx context.Context, db DB) error {
	if t.Exists() {
		return t.Update(ctx, db)
	}
	return t.Insert(ctx, db)
}

// Upsert performs an upsert for Team.
func (t *Team) Upsert(ctx context.Context, db DB) error {
	switch {
	case t._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.teams (` +
		`team_id, team_name, team_icon, team_memo, start_date, end_date, is_end, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`team_name = VALUES(team_name), team_icon = VALUES(team_icon), team_memo = VALUES(team_memo), start_date = VALUES(start_date), end_date = VALUES(end_date), is_end = VALUES(is_end), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, t.TeamID, t.TeamName, t.TeamIcon, t.TeamMemo, t.StartDate, t.EndDate, t.IsEnd, t.CreatedAt, t.UpdatedAt, t.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, t.TeamID, t.TeamName, t.TeamIcon, t.TeamMemo, t.StartDate, t.EndDate, t.IsEnd, t.CreatedAt, t.UpdatedAt, t.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	t._exists = true
	return nil
}

// Delete deletes the Team from the database.
func (t *Team) Delete(ctx context.Context, db DB) error {
	switch {
	case !t._exists: // doesn't exist
		return nil
	case t._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.teams ` +
		`WHERE team_id = ?`
	// run
	logf(sqlstr, t.TeamID)
	if _, err := db.ExecContext(ctx, sqlstr, t.TeamID); err != nil {
		return logerror(err)
	}
	// set deleted
	t._deleted = true
	return nil
}

// User represents a row from 'sample.users'.
type User struct {
	UserID    int            `json:"user_id"`    // user_id
	UserIcon  sql.NullString `json:"user_icon"`  // user_icon
	UserName  string         `json:"user_name"`  // user_name
	Email     string         `json:"email"`      // email
	Password  string         `json:"password"`   // password
	RoleID    sql.NullInt64  `json:"role_id"`    // role_id
	CreatedAt time.Time      `json:"created_at"` // created_at
	UpdatedAt sql.NullTime   `json:"updated_at"` // updated_at
	DeletedAt sql.NullTime   `json:"deleted_at"` // deleted_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the User exists in the database.
func (u *User) Exists() bool {
	return u._exists
}

// Deleted returns true when the User has been marked for deletion from
// the database.
func (u *User) Deleted() bool {
	return u._deleted
}

// Insert inserts the User to the database.
func (u *User) Insert(ctx context.Context, db DB) error {
	switch {
	case u._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case u._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sample.users (` +
		`user_icon, user_name, email, password, role_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, u.UserIcon, u.UserName, u.Email, u.Password, u.RoleID, u.CreatedAt, u.UpdatedAt, u.DeletedAt)
	res, err := db.ExecContext(ctx, sqlstr, u.UserIcon, u.UserName, u.Email, u.Password, u.RoleID, u.CreatedAt, u.UpdatedAt, u.DeletedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	u.UserID = int(id)
	// set exists
	u._exists = true
	return nil
}

// Update updates a User in the database.
func (u *User) Update(ctx context.Context, db DB) error {
	switch {
	case !u._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case u._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sample.users SET ` +
		`user_icon = ?, user_name = ?, email = ?, password = ?, role_id = ?, created_at = ?, updated_at = ?, deleted_at = ? ` +
		`WHERE user_id = ?`
	// run
	logf(sqlstr, u.UserIcon, u.UserName, u.Email, u.Password, u.RoleID, u.CreatedAt, u.UpdatedAt, u.DeletedAt, u.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, u.UserIcon, u.UserName, u.Email, u.Password, u.RoleID, u.CreatedAt, u.UpdatedAt, u.DeletedAt, u.UserID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the User to the database.
func (u *User) Save(ctx context.Context, db DB) error {
	if u.Exists() {
		return u.Update(ctx, db)
	}
	return u.Insert(ctx, db)
}

// Upsert performs an upsert for User.
func (u *User) Upsert(ctx context.Context, db DB) error {
	switch {
	case u._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sample.users (` +
		`user_id, user_icon, user_name, email, password, role_id, created_at, updated_at, deleted_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`user_icon = VALUES(user_icon), user_name = VALUES(user_name), email = VALUES(email), password = VALUES(password), role_id = VALUES(role_id), created_at = VALUES(created_at), updated_at = VALUES(updated_at), deleted_at = VALUES(deleted_at)`
	// run
	logf(sqlstr, u.UserID, u.UserIcon, u.UserName, u.Email, u.Password, u.RoleID, u.CreatedAt, u.UpdatedAt, u.DeletedAt)
	if _, err := db.ExecContext(ctx, sqlstr, u.UserID, u.UserIcon, u.UserName, u.Email, u.Password, u.RoleID, u.CreatedAt, u.UpdatedAt, u.DeletedAt); err != nil {
		return logerror(err)
	}
	// set exists
	u._exists = true
	return nil
}

// Delete deletes the User from the database.
func (u *User) Delete(ctx context.Context, db DB) error {
	switch {
	case !u._exists: // doesn't exist
		return nil
	case u._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sample.users ` +
		`WHERE user_id = ?`
	// run
	logf(sqlstr, u.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, u.UserID); err != nil {
		return logerror(err)
	}
	// set deleted
	u._deleted = true
	return nil
}

// CategoryByCategoryID retrieves a row from 'sample.categories' as a Category.
//
// Generated from index 'categories_category_id_pkey'.
func CategoryByCategoryID(ctx context.Context, db DB, categoryID int) (*Category, error) {
	// query
	const sqlstr = `SELECT ` +
		`category_id, category_name, category_icon, created_at, updated_at, deleted_at ` +
		`FROM sample.categories ` +
		`WHERE category_id = ?`
	// run
	logf(sqlstr, categoryID)
	c := Category{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, categoryID).Scan(&c.CategoryID, &c.CategoryName, &c.CategoryIcon, &c.CreatedAt, &c.UpdatedAt, &c.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}

// TasksByCategoryID retrieves a row from 'sample.tasks' as a Task.
//
// Generated from index 'categories_index'.
func TasksByCategoryID(ctx context.Context, db DB, categoryID int) ([]*Task, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_id, task_name, link, level, description, is_review, is_all_required, category_id, created_at, updated_at, deleted_at ` +
		`FROM sample.tasks ` +
		`WHERE category_id = ?`
	// run
	logf(sqlstr, categoryID)
	rows, err := db.QueryContext(ctx, sqlstr, categoryID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Task
	for rows.Next() {
		t := Task{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.TaskID, &t.TaskName, &t.Link, &t.Level, &t.Description, &t.IsReview, &t.IsAllRequired, &t.CategoryID, &t.CreatedAt, &t.UpdatedAt, &t.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// UserByEmail retrieves a row from 'sample.users' as a User.
//
// Generated from index 'email'.
func UserByEmail(ctx context.Context, db DB, email string) (*User, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, user_icon, user_name, email, password, role_id, created_at, updated_at, deleted_at ` +
		`FROM sample.users ` +
		`WHERE email = ?`
	// run
	logf(sqlstr, email)
	u := User{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, email).Scan(&u.UserID, &u.UserIcon, &u.UserName, &u.Email, &u.Password, &u.RoleID, &u.CreatedAt, &u.UpdatedAt, &u.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &u, nil
}

// JUsersCategoriesByCategoryID retrieves a row from 'sample.j_users_categories' as a JUsersCategory.
//
// Generated from index 'j_categories_index'.
func JUsersCategoriesByCategoryID(ctx context.Context, db DB, categoryID int) ([]*JUsersCategory, error) {
	// query
	const sqlstr = `SELECT ` +
		`j_user_category_id, user_id, category_id, created_at, updated_at, deleted_at ` +
		`FROM sample.j_users_categories ` +
		`WHERE category_id = ?`
	// run
	logf(sqlstr, categoryID)
	rows, err := db.QueryContext(ctx, sqlstr, categoryID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*JUsersCategory
	for rows.Next() {
		juc := JUsersCategory{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&juc.JUserCategoryID, &juc.UserID, &juc.CategoryID, &juc.CreatedAt, &juc.UpdatedAt, &juc.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &juc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// JUsersTeamsByTeamID retrieves a row from 'sample.j_users_teams' as a JUsersTeam.
//
// Generated from index 'j_teams'.
func JUsersTeamsByTeamID(ctx context.Context, db DB, teamID int) ([]*JUsersTeam, error) {
	// query
	const sqlstr = `SELECT ` +
		`j_user_team_id, user_id, team_id, created_at, updated_at, deleted_at ` +
		`FROM sample.j_users_teams ` +
		`WHERE team_id = ?`
	// run
	logf(sqlstr, teamID)
	rows, err := db.QueryContext(ctx, sqlstr, teamID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*JUsersTeam
	for rows.Next() {
		jut := JUsersTeam{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&jut.JUserTeamID, &jut.UserID, &jut.TeamID, &jut.CreatedAt, &jut.UpdatedAt, &jut.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &jut)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// JUsersCategoryByJUserCategoryID retrieves a row from 'sample.j_users_categories' as a JUsersCategory.
//
// Generated from index 'j_users_categories_j_user_category_id_pkey'.
func JUsersCategoryByJUserCategoryID(ctx context.Context, db DB, jUserCategoryID int) (*JUsersCategory, error) {
	// query
	const sqlstr = `SELECT ` +
		`j_user_category_id, user_id, category_id, created_at, updated_at, deleted_at ` +
		`FROM sample.j_users_categories ` +
		`WHERE j_user_category_id = ?`
	// run
	logf(sqlstr, jUserCategoryID)
	juc := JUsersCategory{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, jUserCategoryID).Scan(&juc.JUserCategoryID, &juc.UserID, &juc.CategoryID, &juc.CreatedAt, &juc.UpdatedAt, &juc.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &juc, nil
}

// JUsersCategoriesByUserID retrieves a row from 'sample.j_users_categories' as a JUsersCategory.
//
// Generated from index 'j_users_index1'.
func JUsersCategoriesByUserID(ctx context.Context, db DB, userID int) ([]*JUsersCategory, error) {
	// query
	const sqlstr = `SELECT ` +
		`j_user_category_id, user_id, category_id, created_at, updated_at, deleted_at ` +
		`FROM sample.j_users_categories ` +
		`WHERE user_id = ?`
	// run
	logf(sqlstr, userID)
	rows, err := db.QueryContext(ctx, sqlstr, userID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*JUsersCategory
	for rows.Next() {
		juc := JUsersCategory{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&juc.JUserCategoryID, &juc.UserID, &juc.CategoryID, &juc.CreatedAt, &juc.UpdatedAt, &juc.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &juc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// JUsersTeamsByUserID retrieves a row from 'sample.j_users_teams' as a JUsersTeam.
//
// Generated from index 'j_users_index2'.
func JUsersTeamsByUserID(ctx context.Context, db DB, userID int) ([]*JUsersTeam, error) {
	// query
	const sqlstr = `SELECT ` +
		`j_user_team_id, user_id, team_id, created_at, updated_at, deleted_at ` +
		`FROM sample.j_users_teams ` +
		`WHERE user_id = ?`
	// run
	logf(sqlstr, userID)
	rows, err := db.QueryContext(ctx, sqlstr, userID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*JUsersTeam
	for rows.Next() {
		jut := JUsersTeam{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&jut.JUserTeamID, &jut.UserID, &jut.TeamID, &jut.CreatedAt, &jut.UpdatedAt, &jut.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &jut)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// JUsersTeamByJUserTeamID retrieves a row from 'sample.j_users_teams' as a JUsersTeam.
//
// Generated from index 'j_users_teams_j_user_team_id_pkey'.
func JUsersTeamByJUserTeamID(ctx context.Context, db DB, jUserTeamID int) (*JUsersTeam, error) {
	// query
	const sqlstr = `SELECT ` +
		`j_user_team_id, user_id, team_id, created_at, updated_at, deleted_at ` +
		`FROM sample.j_users_teams ` +
		`WHERE j_user_team_id = ?`
	// run
	logf(sqlstr, jUserTeamID)
	jut := JUsersTeam{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, jUserTeamID).Scan(&jut.JUserTeamID, &jut.UserID, &jut.TeamID, &jut.CreatedAt, &jut.UpdatedAt, &jut.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &jut, nil
}

// MigrationByID retrieves a row from 'sample.migrations' as a Migration.
//
// Generated from index 'migrations_id_pkey'.
func MigrationByID(ctx context.Context, db DB, id string) (*Migration, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, applied_at ` +
		`FROM sample.migrations ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, id)
	m := Migration{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&m.ID, &m.AppliedAt); err != nil {
		return nil, logerror(err)
	}
	return &m, nil
}

// UsersByRoleID retrieves a row from 'sample.users' as a User.
//
// Generated from index 'role_index'.
func UsersByRoleID(ctx context.Context, db DB, roleID sql.NullInt64) ([]*User, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, user_icon, user_name, email, password, role_id, created_at, updated_at, deleted_at ` +
		`FROM sample.users ` +
		`WHERE role_id = ?`
	// run
	logf(sqlstr, roleID)
	rows, err := db.QueryContext(ctx, sqlstr, roleID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*User
	for rows.Next() {
		u := User{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&u.UserID, &u.UserIcon, &u.UserName, &u.Email, &u.Password, &u.RoleID, &u.CreatedAt, &u.UpdatedAt, &u.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &u)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// RoleByRoleID retrieves a row from 'sample.roles' as a Role.
//
// Generated from index 'roles_role_id_pkey'.
func RoleByRoleID(ctx context.Context, db DB, roleID int) (*Role, error) {
	// query
	const sqlstr = `SELECT ` +
		`role_id, role_icon, role_name, created_at, updated_at, deleted_at ` +
		`FROM sample.roles ` +
		`WHERE role_id = ?`
	// run
	logf(sqlstr, roleID)
	r := Role{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, roleID).Scan(&r.RoleID, &r.RoleIcon, &r.RoleName, &r.CreatedAt, &r.UpdatedAt, &r.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &r, nil
}

// TaskStatusByTaskFlagID retrieves a row from 'sample.task_status' as a TaskStatus.
//
// Generated from index 'task_flags_index'.
func TaskStatusByTaskFlagID(ctx context.Context, db DB, taskFlagID int) ([]*TaskStatus, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_state_id, user_id, task_id, task_flag_id, progress, created_at, updated_at, deleted_at ` +
		`FROM sample.task_status ` +
		`WHERE task_flag_id = ?`
	// run
	logf(sqlstr, taskFlagID)
	rows, err := db.QueryContext(ctx, sqlstr, taskFlagID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TaskStatus
	for rows.Next() {
		ts := TaskStatus{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ts.TaskStateID, &ts.UserID, &ts.TaskID, &ts.TaskFlagID, &ts.Progress, &ts.CreatedAt, &ts.UpdatedAt, &ts.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ts)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TaskFlagByTaskFlagID retrieves a row from 'sample.task_flags' as a TaskFlag.
//
// Generated from index 'task_flags_task_flag_id_pkey'.
func TaskFlagByTaskFlagID(ctx context.Context, db DB, taskFlagID int) (*TaskFlag, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_flag_id, task_flag_name, created_at, updated_at, deleted_at ` +
		`FROM sample.task_flags ` +
		`WHERE task_flag_id = ?`
	// run
	logf(sqlstr, taskFlagID)
	tf := TaskFlag{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, taskFlagID).Scan(&tf.TaskFlagID, &tf.TaskFlagName, &tf.CreatedAt, &tf.UpdatedAt, &tf.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &tf, nil
}

// TaskStatusByTaskStateID retrieves a row from 'sample.task_status' as a TaskStatus.
//
// Generated from index 'task_status_task_state_id_pkey'.
func TaskStatusByTaskStateID(ctx context.Context, db DB, taskStateID int) (*TaskStatus, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_state_id, user_id, task_id, task_flag_id, progress, created_at, updated_at, deleted_at ` +
		`FROM sample.task_status ` +
		`WHERE task_state_id = ?`
	// run
	logf(sqlstr, taskStateID)
	ts := TaskStatus{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, taskStateID).Scan(&ts.TaskStateID, &ts.UserID, &ts.TaskID, &ts.TaskFlagID, &ts.Progress, &ts.CreatedAt, &ts.UpdatedAt, &ts.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &ts, nil
}

// TaskStatusByTaskID retrieves a row from 'sample.task_status' as a TaskStatus.
//
// Generated from index 'tasks_index'.
func TaskStatusByTaskID(ctx context.Context, db DB, taskID int) ([]*TaskStatus, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_state_id, user_id, task_id, task_flag_id, progress, created_at, updated_at, deleted_at ` +
		`FROM sample.task_status ` +
		`WHERE task_id = ?`
	// run
	logf(sqlstr, taskID)
	rows, err := db.QueryContext(ctx, sqlstr, taskID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TaskStatus
	for rows.Next() {
		ts := TaskStatus{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ts.TaskStateID, &ts.UserID, &ts.TaskID, &ts.TaskFlagID, &ts.Progress, &ts.CreatedAt, &ts.UpdatedAt, &ts.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ts)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TaskByTaskID retrieves a row from 'sample.tasks' as a Task.
//
// Generated from index 'tasks_task_id_pkey'.
func TaskByTaskID(ctx context.Context, db DB, taskID int) (*Task, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_id, task_name, link, level, description, is_review, is_all_required, category_id, created_at, updated_at, deleted_at ` +
		`FROM sample.tasks ` +
		`WHERE task_id = ?`
	// run
	logf(sqlstr, taskID)
	t := Task{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, taskID).Scan(&t.TaskID, &t.TaskName, &t.Link, &t.Level, &t.Description, &t.IsReview, &t.IsAllRequired, &t.CategoryID, &t.CreatedAt, &t.UpdatedAt, &t.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &t, nil
}

// TeamByTeamID retrieves a row from 'sample.teams' as a Team.
//
// Generated from index 'teams_team_id_pkey'.
func TeamByTeamID(ctx context.Context, db DB, teamID int) (*Team, error) {
	// query
	const sqlstr = `SELECT ` +
		`team_id, team_name, team_icon, team_memo, start_date, end_date, is_end, created_at, updated_at, deleted_at ` +
		`FROM sample.teams ` +
		`WHERE team_id = ?`
	// run
	logf(sqlstr, teamID)
	t := Team{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, teamID).Scan(&t.TeamID, &t.TeamName, &t.TeamIcon, &t.TeamMemo, &t.StartDate, &t.EndDate, &t.IsEnd, &t.CreatedAt, &t.UpdatedAt, &t.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &t, nil
}

// UserByUserID retrieves a row from 'sample.users' as a User.
//
// Generated from index 'users_user_id_pkey'.
func UserByUserID(ctx context.Context, db DB, userID int) (*User, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, user_icon, user_name, email, password, role_id, created_at, updated_at, deleted_at ` +
		`FROM sample.users ` +
		`WHERE user_id = ?`
	// run
	logf(sqlstr, userID)
	u := User{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID).Scan(&u.UserID, &u.UserIcon, &u.UserName, &u.Email, &u.Password, &u.RoleID, &u.CreatedAt, &u.UpdatedAt, &u.DeletedAt); err != nil {
		return nil, logerror(err)
	}
	return &u, nil
}

// TaskStatusByUserID retrieves a row from 'sample.task_status' as a TaskStatus.
//
// Generated from index 'uses_index'.
func TaskStatusByUserID(ctx context.Context, db DB, userID int) ([]*TaskStatus, error) {
	// query
	const sqlstr = `SELECT ` +
		`task_state_id, user_id, task_id, task_flag_id, progress, created_at, updated_at, deleted_at ` +
		`FROM sample.task_status ` +
		`WHERE user_id = ?`
	// run
	logf(sqlstr, userID)
	rows, err := db.QueryContext(ctx, sqlstr, userID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TaskStatus
	for rows.Next() {
		ts := TaskStatus{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ts.TaskStateID, &ts.UserID, &ts.TaskID, &ts.TaskFlagID, &ts.Progress, &ts.CreatedAt, &ts.UpdatedAt, &ts.DeletedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ts)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// User returns the User associated with the JUsersCategory's (UserID).
//
// Generated from foreign key 'j_users_categories_ibfk_1'.
func (juc *JUsersCategory) User(ctx context.Context, db DB) (*User, error) {
	return UserByUserID(ctx, db, juc.UserID)
}

// Category returns the Category associated with the JUsersCategory's (CategoryID).
//
// Generated from foreign key 'j_users_categories_ibfk_2'.
func (juc *JUsersCategory) Category(ctx context.Context, db DB) (*Category, error) {
	return CategoryByCategoryID(ctx, db, juc.CategoryID)
}

// User returns the User associated with the JUsersTeam's (UserID).
//
// Generated from foreign key 'j_users_teams_ibfk_1'.
func (jut *JUsersTeam) User(ctx context.Context, db DB) (*User, error) {
	return UserByUserID(ctx, db, jut.UserID)
}

// Team returns the Team associated with the JUsersTeam's (TeamID).
//
// Generated from foreign key 'j_users_teams_ibfk_2'.
func (jut *JUsersTeam) Team(ctx context.Context, db DB) (*Team, error) {
	return TeamByTeamID(ctx, db, jut.TeamID)
}

// User returns the User associated with the TaskStatus's (UserID).
//
// Generated from foreign key 'task_status_ibfk_1'.
func (ts *TaskStatus) User(ctx context.Context, db DB) (*User, error) {
	return UserByUserID(ctx, db, ts.UserID)
}

// Task returns the Task associated with the TaskStatus's (TaskID).
//
// Generated from foreign key 'task_status_ibfk_2'.
func (ts *TaskStatus) Task(ctx context.Context, db DB) (*Task, error) {
	return TaskByTaskID(ctx, db, ts.TaskID)
}

// TaskFlag returns the TaskFlag associated with the TaskStatus's (TaskFlagID).
//
// Generated from foreign key 'task_status_ibfk_3'.
func (ts *TaskStatus) TaskFlag(ctx context.Context, db DB) (*TaskFlag, error) {
	return TaskFlagByTaskFlagID(ctx, db, ts.TaskFlagID)
}

// Category returns the Category associated with the Task's (CategoryID).
//
// Generated from foreign key 'tasks_ibfk_1'.
func (t *Task) Category(ctx context.Context, db DB) (*Category, error) {
	return CategoryByCategoryID(ctx, db, t.CategoryID)
}

// Role returns the Role associated with the User's (RoleID).
//
// Generated from foreign key 'users_ibfk_1'.
func (u *User) Role(ctx context.Context, db DB) (*Role, error) {
	return RoleByRoleID(ctx, db, int(u.RoleID.Int64))
}
